%require "3.8"
%language "c++"
%skeleton "lalr1.cc"

%verbose
%define parse.trace

%define api.namespace {parse}
%define api.value.type variant
%define api.token.constructor
%define api.parser.class {Parser}
%define parse.error verbose

%defines
%output "parser.cpp"

%locations
%define api.location.file "location.h"

%code requires {
    namespace parse {
        class Lexer;
    }
  #include "misc/symbol.h"
}

%parse-param { parse::Lexer& lexer }

%code{
  #include "lex.yy.h"  // header file generated with reflex --header-file
  #undef yylex
  #define yylex lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()
}

%define api.token.prefix {TOK_}

%printer { yyo << $$; } <int> <misc::symbol>

%expect 0

%token <misc::symbol> ID
%token <int> INT_VAL

%token INT "int"
%token VOID "void"
%token RETURN "return"
%token SEMI ";"
%token LPAREN "("
%token RPAREN ")"
%token LBRACE "{"
%token RBRACE "}"

%token EOF 0

%start translation_unit

// Following the grammar specified in the C99 standard
%%
translation_unit
    : extern_decl
    | translation_unit extern_decl
    ;

extern_decl
    : func_def
    | decl
    ;

func_def
    : decl_spec declarator decl_list cmpd_stmt
    // FIXME: direct_declarators can yield IDs. In such case the parser will accept and reduce the declarator nterm
    // and continue towards to cmpd_stmt.
    | decl_spec declarator cmpd_stmt
    ;

decl_list
    : decl
    | decl_list decl
    ;

cmpd_stmt
    : "{" "}"
    | "{" blk_item_list "}"
    ;

blk_item_list
    : blk_item
    | blk_item_list blk_item
    ;

blk_item
    : decl
    | stmt
    ;

decl
    : decl_spec init_declarator_list_opt ";"
    ;

decl_spec
    : type_spec decl_spec_opt
    // TODO: all specifiers
    ;

decl_spec_opt
    : %empty
    | decl_spec
    ;

type_spec
    : "int"
    | "void"
    ;

parameter_type_list
    : parameter_list
    | "void"
    // TODO: Variadic parameters
    ;

parameter_list
    : parameter_declaration
    // TODO: multiple parameters
    ;

parameter_declaration
    : decl_spec declarator
    // TODO: Abstract declarators
    ;

init_declarator_list_opt
    : %empty
    | init_declarator_list
    ;

init_declarator_list
    : init_declarator
    | init_declarator_list "," init_declarator
    ;

init_declarator
    : declarator
    | declarator "=" initializer
    ;

declarator
    : direct_declarator
     // TODO : Pointers
    ;

direct_declarator
    : ID
    | direct_declarator "(" parameter_type_list ")"
    | direct_declarator "(" identifier_list ")"
    ;

identifier_list
    : %empty
    // NOTE: For now, this is needed to parse empty paren function decls
    ;

stmt
    : jump_stmt
    ;

jump_stmt
    : "return" expr ";"
    // TODO: other stmts
    ;

expr
    : assign_expr
    // TODO : comma sep exprs
    ;

assign_expr
    : conditional_expr
    // TODO : assignment exprs
    ;

conditional_expr
    : logic_or_expr
    // TODO: saving time, everything below will be incomplete
    ;

logic_or_expr
    : logic_and_expr
    ;

logic_and_expr
    : incl_or_expr
    ;

incl_or_expr
    : excl_or_expr
    ;

excl_or_expr
    : and_expr
    ;

and_expr
    : eq_expr
    ;

eq_expr
    : relational_expr
    ;

relational_expr
    : shift_expr
    ;

shift_expr
    : add_expr
    ;

add_expr
    : mul_expr
    ;

mul_expr
    : cast_expr
    ;

cast_expr
    : unary_expr
    ;

unary_expr
    : primary_expr
    ;

primary_expr
    : ID
    | constant
    ;

constant
    : int_constant
    ;

int_constant
    : INT_VAL /* int_suffix */
    ;

initializer
    : assign_expr
    | "{" initializer_list "}"
    | "{" initializer_list "," "}"
    ;

initializer_list
    : designation_opt initializer
    | initializer_list "," designation_opt initializer
    ;

designation_opt
    : %empty
    | designation
    ;

designation
    : designator_list "="
    ;

designator_list
    : designator
    | designator_list designator
    ;

designator
    : "[" constant_expr "]"
    | "." ID
    ;

constant_expr
    : conditional_expr
    ;
%%

void parse::Parser::error(const location& loc, const std::string& msg)
{
  // FIXME: source file name here
  std::cerr << loc << ": " << msg << std::endl;
  if (lexer.size() == 0)      // if token is unknown (no match)
    lexer.matcher().winput(); // skip character
}
